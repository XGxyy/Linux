一.死锁:(多个执行流在对多个锁资源进行争抢操作,但是因为推进顺序不当,而导致互相等待,流程无法继续推进的情况)
死锁产生的四个必要条件:
	1.互斥条件: 一个所只有一个人能加,我加了锁,担任就不能加了
	2.不可剥夺条件: 我加的锁, 别人不能替我释放
	3.请求与保持条件: 我加了A锁,然后去请求B锁,但是请求不到B锁,我也不释放A锁
	4.环路等待条件:我拿着A锁去请求B锁,对方拿着B锁请求A锁

二.预防死锁: 破坏产生死锁的四个必要条件
	锁资源按序一次性分配: 加锁的时候可以使用非阻塞加锁, 若无法加锁,则将手中的其他锁释放掉

三.避免死锁:银行家算法, 死锁检测算法 

四.读者写者模型:
	少量写临界资源的执行流+大量读临界资源的执行流
	不能同时写,但是可以同时读
	写的时候别人既不能写,也不能读; 但是读的时候大家可以一起读,但是读的时候不能写
	写互斥,读共享 ---读写锁
**读写锁的实现:
	一个读者技术: >0, 表示当前有人正在读, 想要加写锁的人就需要等待, 而想要加读写锁可以继续加
	一个写着计数: >0, 表示当前有人正在写, 想要加写锁的人就需要等待,想要加读锁的人也需要等待
	其中不能加锁时的等待,通过自旋锁实现
	*自旋锁:循环判断条件,并且强占cpu(一直处于运行状态,判断条件,cpu不可被剥夺)
	比较消耗cpu, 比较适用于等待时间比较短的操作
